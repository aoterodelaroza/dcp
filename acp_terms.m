#! /usr/bin/octave -q
% Copyright (C) 2015 Alberto Otero-de-la-Roza <aoterodelaroza@gmail.com>
%
% acp is free software: you can redistribute it and/or modify it under
% the terms of the GNU General Public License as published by the Free
% Software Foundation, either version 3 of the License, or (at your
% option) any later version. See <http://www.gnu.org/licenses/>.
%
% The routine distributed in the hope that it will be useful, but WITHOUT
% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
% FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
% more details.

format long
global acp basis db prefix nstep run_inputs ycur...
       acpfin costmin stime0 astep savetar ncpu mem...
       ferr

#### Modify this to change the input behavior ####

## Functional
method="hf";

## Basis set or basis file or files. You can use a single string
## or a cell array. If you use a string, then the script will look
## for a file by that name. If the file does not exist, then the string
## will be assumed to be a Gaussian keyword and passed to the input
## If a file is found, it is parsed and the basis-set information read,
## then information for the relevant atoms passed to the inputs. 
## Several basis set files can be used (e.g. {"basis1","basis2"}).
basis="minis.gbs";

## Extra bits for gaussian (do not include pseudo=read or scf=maxcycle
## here). 
extragau="Symm=none int=(grid=ultrafine)";

## Number of CPUs and memory (in GB) for Gaussian runs
ncpu=8;
mem=2;

## List of database files to use in ACP optimization
listdb = {...
           "atz_hf/energy_c.db",...
           "atz_hf/energy_h.db",...
           "atz_hf/energy_n.db",...
           "atz_hf/energy_o.db",...
};

## Use this keyword to select a particular reference energy. Empty
## usually means high-level reference data. Other options are, for 
## instance, blyp/aqz or lcwpbe/atz.
reftype="";

## List of atoms
atoms = {"H","C","O","N"};

## Maximum angular momentum channel for each atom
lchan = {"s","p","p","p"};

## List of exponents
lexp = [0.08 0.10 0.12];

## The coefficient for the post-SCF calculation of the ACP term
c0 = 0.001;

## Prefix for the calculations. If prefix is "bleh", then all the
## inputs and outputs will be stored in subdirectory bleh/ of the
## current working directory. The file names will be bleh_xx.tar.bz2
## where xx is the ACP optimization evaluation number. The archive
## contains files bleh_xx_name, where name is the identifier for the
## database entry. 
prefix="bleh";

## Name of the Gaussian input runner routine
run_inputs = @run_inputs_serial; ## Run all Gaussian inputs sequentially on the same node
## run_inputs = @run_inputs_grex; ## Submit inputs to the queue, wait for all to finish. Grex version.
## run_inputs = @run_inputs_plonk; ## Submit inputs to a private queue, plonk version.
## run_inputs = @run_inputs_plonk_priority; ## plonk version, high priority.
## run_inputs = @run_inputs_plonk_packed; ## plonk version, pack the inputs.
## run_inputs = @run_inputs_nint; ## Submit inputs to a private queue on the NINT cluster.
## run_inputs = @run_inputs_nint_gino; ## Submit inputs to a private queue on the NINT cluster (gino).
## run_inputs = @run_inputs_elcap3; ## Submit inputs to elcap3.
## run_inputs = @run_inputs_pass; ## Create the inputs and do not run anything.
## run_inputs = @run_inputs_read; ## Read the outputs in the directories generated by run_inputs_pass

## Save a compressed tar file with the inputs/outputs/wfxs?
## savetar="";
## savetar="tar";
## savetar="gz";
savetar="bz2";
## savetar="xz";

## Name of the error file (timing, debug, etc.)
errfile = "eval.err";

#### No touching past this point. ####

## Open error file
ferr = -1;
if (exist("errfile","var"))
  ferr = fopen(errfile,"w");
endif

## Header
printf("### ACP term calculation started on %s ###\n",strtrim(ctime(time())));
printf("### PID: %d ###\n",getpid());
[s out] = system("hostname");
printf("### hostname: %s ###\n",strrep(out,"\n",""));
if (ferr > 0) 
  fprintf(ferr,"# Started on %s with PID %d (%s)\n",strtrim(ctime(time())),getpid(),strrep(out,"\n",""));
  fflush(ferr);
endif

## Read the basis set
basis = parsebasis(basis);

## Read the parametrization database 
db = parsedb(listdb,reftype);
db = filldb(db,[],method,extragau);

## Create the prefix directory if it doesn't exist yet
if (!exist(prefix,"dir"))
  [s out] = system(sprintf("mkdir %s",prefix));
  if (s != 0)
    error(sprintf("Could not create directory %s",prefix));
  endif
endif

## Initialize
ilist = {};
nstep = 1;

## Set up the Gaussian input files
if (ferr > 0) 
  fprintf(ferr,"# Setting up Gaussian input files - %s\n",strtrim(ctime(time())));
  fflush(ferr);
endif
for i = 1:length(db)
  anew = setup_input_one_postscf(db{i},atoms,lchan,lexp,c0,0,!strcmp(func2str(run_inputs),"run_inputs_read"));
  ilist = {ilist{:}, anew{:}};
endfor
if (ferr > 0) 
  fprintf(ferr,"# List of inputs has %d entries\n",length(ilist));
  fflush(ferr);
endif

## Run all inputs
srun = run_inputs(ilist);

## count the number of terms and prepare angular momentum label indices
nterm = 0;
l2num = struct();
l2num.l = 1; l2num.s = 2; l2num.p = 3; l2num.d = 4;
llabel = {"l","s","p","d"};
for i = 1:length(atoms)
  if (!isfield(l2num,lower(lchan{i})))
    error(sprintf("Unknown angular momentum channel: %s",lchan{iatom}));
  else
    lmax = getfield(l2num,(lower(lchan{i})));
  endif
  for j = 1:lmax
    nterm = nterm + length(lexp);
  endfor
endfor

## Collect the results 
if (ferr > 0) 
  fprintf(ferr,"# Collecting the results - %s\n",strtrim(ctime(time())));
  fflush(ferr);
endif
xterm = zeros(nterm,length(db));
xempty = zeros(1,length(db));
for i = 1:length(db)
  [x1 x2] = process_output_one_postscf(db{i},atoms,lchan,lexp,0);
  xterm(:,i) = x1(:);
  xempty(i) = x2;
endfor

## Write output
n = 0;
for iatom = 1:length(atoms)
  for il = 1:getfield(l2num,lower(lchan{iatom}))
    for iexp = 1:length(lexp)
      n = n + 1;

      ## standard output
      printf("## Atom: %s Channel: %s Exponent: %.10f\n",atoms{iatom},llabel{il},lexp(iexp));
      for i = 1:length(db)
        printf("| %d | %s | %.10f |\n",i,db{i}.outname,xterm(n,i));
      endfor
      printf("\n")

      ## data file
      file = sprintf("%s_%s_%d.dat",lower(atoms{iatom}),llabel{il},iexp);
      printf("## Written in data file: %s\n",file);
      fid = fopen(file,"w");
      for i = 1:length(db)
        fprintf(fid,"%.10f\n",xterm(n,i));
      endfor
      fclose(fid);
    endfor
  endfor
endfor

## empty data file
file = "empty.dat";
printf("## Written data file: %s\n",file);
fid = fopen(file,"w");
for i = 1:length(db)
  fprintf(fid,"%.10f\n",xempty(i));
endfor
fclose(fid);

## names data file
file = "names.dat";
printf("## Written data file: %s\n",file);
fid = fopen(file,"w");
for i = 1:length(db)
  fprintf(fid,"%s\n",db{i}.outname);
endfor
fclose(fid);

## reference data file
file = "ref.dat";
printf("## Written data file: %s\n",file);
fid = fopen(file,"w");
for i = 1:length(db)
  fprintf(fid,"%.10f\n",db{i}.ref);
endfor
fclose(fid);

## Clean up
stash_inputs_outputs(xempty);

## Close error file
if (ferr > 0) 
  fprintf(ferr,"# Finished on %s\n",strtrim(ctime(time())));
  fflush(ferr);
endif
fclose(ferr);

## Termination
printf("### ACP term calculation finished on %s ###\n",strtrim(ctime(time())));
