#! /usr/bin/octave -q
% Copyright (C) 2015 Alberto Otero-de-la-Roza <aoterodelaroza@gmail.com>
%
% acp is free software: you can redistribute it and/or modify it under
% the terms of the GNU General Public License as published by the Free
% Software Foundation, either version 3 of the License, or (at your
% option) any later version. See <http://www.gnu.org/licenses/>.
%
% The routine distributed in the hope that it will be useful, but WITHOUT
% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
% FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
% more details.

format long
global acp basis db prefix nstep run_inputs savetar ncpu mem ferr

#### Modify this to change the input behavior ####

## Functional
method="hf";

## Basis set or basis file or files. You can use a single string
## or a cell array. If you use a string, then the script will look
## for a file by that name. If the file does not exist, then the string
## will be assumed to be a Gaussian keyword and passed to the input
## If a file is found, it is parsed and the basis-set information read,
## then information for the relevant atoms passed to the inputs. 
## Several basis set files can be used (e.g. {"basis1","basis2"}).
basis="sto-3g";

## Extra bits for gaussian (do not include pseudo=read here)
extragau="SCF=(Conver=8, MaxCycle=80) Symm=none int=(grid=ultrafine)";

## Number of CPUs and memory (in GB) for Gaussian runs
ncpu=8;
mem=2;

## List of database files to use in ACP linearity test
## [listdb weightdb] = training_set(1,1,1,1,1);
listdb = {...
           "h2o_shields/water2Cs.db",...
           "h2o_shields/water3UUD.db",...
           "h2o_shields/water3UUU.db",...
           "atz_b3lyp/bdex_oh-h-04.db",...
};

## Atom/channel/exponent list for which the non-linearity test will be
## run.
atom="O";
channel="l";
explist=[0.01 0.1 1.0];

## Base coefficient for the linearity range exploration
cmin=0.00001;

## Maximum and minimum coefficient values
cmax = 2.1;

## Scaling factor for the coefficient exploration
cfactor = 2;

## Threshold for the non-linearity error (kcal/mol)
nonlinthr = 1e-3;

## Prefix for the calculations. If prefix is "bleh", then all the
## inputs and outputs will be stored in subdirectory bleh/ of the
## current working directory. The file names will be bleh_xx.tar.bz2
## where xx is the ACP optimization evaluation number. The archive
## contains files bleh_xx_name, where name is the identifier for the
## database entry. 
prefix0="bleh";

## Name of the Gaussian input runner routine
run_inputs = @run_inputs_serial; ## Run all Gaussian inputs sequentially on the same node
## run_inputs = @run_inputs_grex; ## Submit inputs to the queue, wait for all to finish. Grex version.
## run_inputs = @run_inputs_plonk; ## Submit inputs to a private queue, plonk version.
## run_inputs = @run_inputs_plonk_priority; ## plonk version, high priority.
## run_inputs = @run_inputs_plonk_packed; ## plonk version, pack the inputs.
## run_inputs = @run_inputs_nint; ## Submit inputs to a private queue on the NINT cluster.
## run_inputs = @run_inputs_nint_gino; ## Submit inputs to a private queue on the NINT cluster (gino).
## run_inputs = @run_inputs_elcap3; ## Submit inputs to elcap3.
## run_inputs = @run_inputs_pass; ## Create the inputs and do not run anything.
## run_inputs = @run_inputs_read; ## Read the outputs in the directories generated by run_inputs_pass

## Save a compressed tar file with the inputs/outputs/wfxs?
## savetar="";
## savetar="tar";
## savetar="gz";
## savetar="bz2";
savetar="xz";

## Name of the error file (timing, debug, etc.)
errfile = "eval.err";

#### No touching past this point. ####

## c0 for the ACP terms;
c0 = 0.001;

## Open error file
ferr = -1;
if (exist("errfile","var"))
  ferr = fopen(errfile,"w");
endif

## Header
printf("### ACP non-linearity tests started on %s ###\n",strtrim(ctime(time())));
printf("### PID: %d ###\n",getpid());
[s out] = system("hostname");
printf("### hostname: %s ###\n",strrep(out,"\n",""));
if (ferr > 0) 
  fprintf(ferr,"# Started on %s with PID %d (%s)\n",strtrim(ctime(time())),getpid(),strrep(out,"\n",""));
  fflush(ferr);
endif

## Read the basis set
basis = parsebasis(basis);

## Read the parametrization database 
db = parsedb(listdb);
db = filldb(db,[],method,extragau);

## Discard the elements that do not contain the current atom
iuse = ones(1,length(listdb));
for i = 1:length(db)
  found = 0;
  for j = 1:db{i}.nmol
    for k = 1:db{i}.molc{j}.nat
      if (strcmpi(db{i}.molc{j}.at{k},atom)) 
        found = 1;
        break
      endif
    endfor
    if (found)
      break
    endif
  endfor
  iuse(i) = found;
endfor
printf("### Using %d out of the original %d db entries ###\n",sum(iuse),length(db));
db = db(find(iuse));

## Calculate the ACP terms
printf("\n### Calculating the ACP terms for each exponent###\n");
prefix = sprintf("%s-terms",prefix0);
nstep = 1;
ilist = {};

## Prepare the inputs
if (ferr > 0) 
  fprintf(ferr,"# Setting up Gaussian input files - %s\n",strtrim(ctime(time())));
  fflush(ferr);
endif
for i = 1:length(db)
  anew = setup_input_one_postscf(db{i},{atom},{channel},explist,c0,1);
  ilist = {ilist{:}, anew{:}};
endfor
if (ferr > 0) 
  fprintf(ferr,"# List of inputs has %d entries\n",length(ilist));
  fflush(ferr);
endif

## Run all inputs
srun = run_inputs(ilist);

## Collect the results 
yterm = zeros(length(explist),length(db));
yempty = zeros(1,length(db));
for i = 1:length(db)
  [x1 x2] = process_output_one_postscf(db{i},{atom},{channel},explist,1);
  yterm(:,i) = x1(:);
  yempty(i) = x2;
endfor

## Write output
for iexp = 1:length(explist)
  printf("## Atom: %s Channel: %s Exponent: %.10f Coefficient: %.10f\n",atom,channel,explist(iexp),c0);
  printf("| Id | Name | Empty | ACP term |\n");
  for i = 1:length(db)
    printf("| %d | %s | %.10f | %.10f |\n",i,db{i}.outname,yempty(i),yterm(iexp,i));
  endfor
  printf("\n")
endfor

## Clean up
stash_inputs_outputs(yempty);

## enter main loop
printf("\n### Calculating the maxcoef for each exponent ###\n");
maxcoef = zeros(1,length(explist));
for iexp = 1:length(explist)
  exponent = explist(iexp);
  printf("\n### Exponent: %.10f ###\n",exponent)

  ## Create the prefix directory if it doesn't exist yet
  prefix = sprintf("%s-%2.2d",prefix0,iexp);
  if (!exist(prefix,"dir"))
    [s out] = system(sprintf("mkdir %s",prefix));
    if (s != 0)
      error(sprintf("Could not create directory %s",prefix));
    endif
  endif

  ## Explore the coefficient limits of this exponent
  nstep = 0;
  c = cmin / cfactor;
  irunup = ones(1,length(db));
  coefup = zeros(1,length(db)) + cmin;
  while true 
    nstep++;

    ## build the next run
    c = c * cfactor;
    acp = makeacp(atom,channel,exponent,c);

    ## Debug
    if (ferr > 0) 
      fprintf(ferr,"# Step %d - Coefficient %.10f - %s\n",nstep,c,strtrim(ctime(time())));
      fflush(ferr);
    endif

    ## Set up the Gaussian input files
    if (ferr > 0) 
      fprintf(ferr,"# Setting up Gaussian input files - %s\n",strtrim(ctime(time())));
      fflush(ferr);
    endif
    ilist = {};
    for i = 1:length(db)
      if (irunup(i))
        anew = setup_input_one(db{i},acp);
        ilist = {ilist{:}, anew{:}};
      endif
    endfor
    if (ferr > 0) 
      fprintf(ferr,"# List of inputs has %d entries\n",length(ilist));
      fflush(ferr);
    endif

    ## Run all inputs
    srun = run_inputs(ilist);

    ## Collect the results 
    if (ferr > 0) 
      fprintf(ferr,"# Collecting the results and calculating errors - %s\n",strtrim(ctime(time())));
      fflush(ferr);
    endif
    ycalc = zeros(1,length(db));
    for i = 1:length(db)
      if (irunup(i))
        [xdum1 ycalc(i) xdum2 xdum3 xdum4] = process_output_one(db{i});
      else
        ycalc(i) = 0;
      endif
    endfor

    ## Save and write the results
    ycur = ycalc - yempty;
    yls = (yterm(iexp,:)-yempty) * c / c0;
    nonlin = abs(ycur - yls);
    printf("# Step %d - Coefficient = %.10f\n",nstep,c);
    printf("| Id|        Name       |       yempty    |   yacp(ls)     |     yacp(scf)   |   non-lin |\n");
    for i = 1:length(db)
      if (irunup(i))
        printf("| %d | %20s | %14.8f | %14.8f | %14.8f | %14.8f |\n",i,db{i}.outname,yempty(i),yls(i),ycur(i),nonlin(i));
      else
        printf("| %d | %20s | c0=%.10f | xxdonexx | xxdonexx | xxdonexx |\n",i,db{i}.outname,coefup(i));
      endif
    endfor
    printf("\n");

    ## Clean up
    stash_inputs_outputs(ycalc);

    ## Check there are no inf in the ycalc
    if (any(ycalc == Inf))
      error("Some of the outputs were Inf")
    endif

    ## Save the coefficients
    irunup = irunup & (nonlin <= nonlinthr);
    coefup(find(nonlin <= nonlinthr)) = c;

    ## Exit conditions
    if (c > cmax) 
      printf("# c (%f) > cmax (%f) condition met\n\n",c,cmax);
      coefup(find(irunup)) = cmax;
      break
    endif
    if (all(!irunup))
      printf("# found maximum coefficients for all systems\n\n",c,cmax);
      break
    endif
  endwhile

  ## Print the final coefficients
  printf("#### Maximum Coefficients for exponent %.10f ####\n",exponent);
  printf("cmax = %.10f\n",min(coefup));
  printf("| Id|        Name       |       cmax     |\n");
  for i = 1:length(db)
    printf("| %d | %20s | %.10f |\n",i,db{i}.outname,coefup(i));
  endfor
  printf("\n");
  maxcoef(iexp) = min(coefup);
endfor

## Close error file
if (ferr > 0) 
  fprintf(ferr,"# Finished on %s\n",strtrim(ctime(time())));
  fflush(ferr);
endif
fclose(ferr);

## Print the final coefficients
printf("#### Final list of coefficients ####\n",exponent);
printf("| Id| Exponent | maxcoef |\n");
for i = 1:length(explist)
  printf("| %d | %.10f | %.10f |\n",i,explist(i),maxcoef(i));
endfor
printf("\n");
printf("# maxcoef data file:\n");
for i = 1:length(explist)
  printf("%d %s %s %.10f %.10f\n",i,atom,channel,...
         explist(i),maxcoef(i));
endfor
printf("\n");

## Termination
printf("### ACP non-linearity tests finished on %s ###\n",strtrim(ctime(time())));
